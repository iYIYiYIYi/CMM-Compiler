options {
    STATIC = true;
    UNICODE_INPUT = true;
    LOOKAHEAD = 2;
}

PARSER_BEGIN(CMM_PARSER)
package grammar.generator;
import java.io.*;

class CMM_PARSER {

    public static void main(String[] args) throws ParseException{
        CMM_PARSER parser = new CMM_PARSER(System.in);
        parser.program();

    }

}

PARSER_END(CMM_PARSER)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

SPECIAL_TOKEN : {
<LINE_COMMENT:"//"(~["\n","\r"]) * ("\n" | "\r\n"|"\r")?>
}

TOKEN : {
< IMPORT : "import">
| <IF : "if">
| <ELSE : "else">
| <WHILE : "while">
| <RETURN : "return">
}

TOKEN : {
<ADD : "+">
| <SUB : "-">
| <MUL : "*">
| <DIV : "/">
| <MOD : "%">
| <AB : ">">
| <BL : "<">
| <ASS : "=">
| <EQ : "==">
| <LB : "{">
| <RB : "}">
| <LM : "[">
| <RM : "]">
| <LS : "(">
| <RS : ")">
| <SEM : ",">
}

TOKEN : {
<ID : ["a"-"z","A"-"Z","_"](["a"-"z","A"-"Z","_","0"-"9"])*>
|<NUM : (< DIGIT >)+ >
| < #DIGIT : [ "0"-"9" ]>
}

void program () :
{}
{
    stmt_seq()
}

void stmt_seq() :
{
    Token id = null;
    System.out.println("stmt_seq clause");
}
{
    <ID>
    {

       System.out.println(id.getValue());
    } <LS> (arg_stmt() <RS> <LB> fun_stmt() <RB> stmt_seq() | <RS> <LB> fun_stmt() <RB> stmt_seq())
    |arg_stmt() ";" stmt_seq()
    |ass_stmt() stmt_seq()
    |epsilon()

}

void arg_stmt() :
{}
{
    <ID><SEM> arg_stmt()
    |<ID>
}

void fun_stmt() :
{}
{
    stmt() fun_stmt()
    | epsilon()
}

void stmt() :
{}
{
    if_stmt()
    | loop_stmt()
    | ass_stmt()
    | return_stmt()
    | call_stmt()
}

void call_stmt():
{

}
{
    <ID> <LS> (arg_stmt()|epsilon()) <RS> ";"
}

void if_stmt() :
{
    System.out.println("if clause");
}
{
    <IF><LS> exp() <RS><LB> (stmt()|epsilon()) <RB> (<ELSE> <LB> (stmt()|epsilon()) <RB> | epsilon() )
}

void ass_stmt() :
{}
{
    <ID> <ASS> exp() ";"
}

void loop_stmt() :
{}
{
    <WHILE> <LS> exp() <RS> <LB> (stmt()|epsilon()) <RB>
}

void return_stmt() :
{}
{
    <RETURN> exp() ";"
}

void exp() :
{}
{
    simple_exp() (<BL> simple_exp()
    		| <EQ> simple_exp()
    		| <AB> simple_exp()
    		| epsilon() )
}

void simple_exp() :
{}
{
    term() simple_exp1()
}

void simple_exp1():
{}
{
    <SUB> term() simple_exp1()
    |<ADD> term() simple_exp1()
    |epsilon()
}


void term() :
{}
{
    factor() term1()
}

void term1() :
{}
{
    <DIV> factor() term1()
    |<MUL> factor() term1()
    |epsilon()
}

void factor() :
{}
{
    <LS> exp() <RS>
    |<NUM>
    |<ID>
}

void epsilon() : { } {
    {}
}











